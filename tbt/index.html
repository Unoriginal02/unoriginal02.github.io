<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Blind Timer</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
        integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous">


    <style>
        body {
            background-color: #000000;
            /* Dark background */
            color: #f8f9fa;
            /* Light text color */
        }

        h1 {
            font-family: 'Bebas Neue', sans-serif;
            text-align: center;
        }

        #countdown-display {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 128px;
            text-align: center;
            /* Center the countdown display */
            margin-top: 0;
            /* Remove the top margin to place it at the top */
            color: #eeeeee;
        }

        .target-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            text-align: center;
            /* Center the countdown display */
            margin-top: 0;
            /* Remove the top margin to place it at the top */
            color: #eeeeee;
        }

        .content-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100vh;
        }

        .content-group {
            width: 100%;
            max-width: 640px;
            /*(Original 640px)*/
        }

        .shaking {
            animation: shake 0.3s infinite;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        #time-grid {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fill, 4px);
            /* Adjust to fit 4x4px squares */
            grid-gap: 4px;
            /* Gap of 2px between squares */
            justify-content: center;
            /* Center grid items */
        }

        .time-square {
            width: 4px;
            height: 4px;
            background-color: #eeeeee;
            /* Very light gray */
            margin: 0px;
            /* Gap of 2px between squares */
        }


        .time-square.yellow {
            background-color: #ffc107;
            /* Bootstrap orange */
        }

        .time-square.red {
            background-color: #dc3545;
            /* Bootstrap red */
        }

        .content-wrapper {
            display: flex;
            height: 100%;
            border: 0px solid #eeeeee;
            margin: 0;
            padding: 0;
            align-items: center;
            justify-content: center;
        }

        .button-wrapper {
            display: flex;
            justify-content: stretch;
        }

        .brutalButton {
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #eeeeee;
            background-color: #000000;
            color: #eeeeee;
            flex: 1;
            /* Flex grow to fill available space */
            margin-right: -1px;
            /* Overlap borders */
            padding: .5rem 0;
        }

        .subtimer-display-container {
            display: flex;
            gap: .25rem;
        }

        .subTimerStyle {
            font-family: 'JetBrains Mono', monospace;
            color: #eeeeee;
            margin-bottom: 1rem;
            flex: 1;
            border-radius: .25rem;
            /* Overlap borders */
            padding: .5rem .5rem;
        }

        .brutalButton:hover {
            background-color: #222222;
        }

        .brutalButton:last-child {
            margin-right: 0;
        }

        .brutalInput {
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #eeeeee;
            background-color: #000000;
            color: #eeeeee;
            padding: .5rem .5rem;
            height: 42px;
            margin-right: -1px;
            /* Overlap borders */
            border-radius: 0;
            text-align: center;
        }

        button:focus {
            /* outline: 1px dotted; */
            outline: 0px auto -webkit-focus-ring-color;
            background-color: rgba(255, 255, 255, .1);
        }

        .form-control:focus {
            background-color: rgba(255, 255, 255, .1) !important;
            border-color: #eeeeee;
            outline: 0;
            box-shadow: none;
        }

        .brutalInput:focus {
            background-color: #333333;
            color: #eeeeee;
            /* Change text color to light gray when focused */
            outline: none;
            /* Remove the default focus outline */
        }

        .brutalInput::placeholder {
            /* Change the color of placeholders */
            color: #bbbbbb;
        }

        @media (min-width: 1200px) {
            .container {
                max-width: 100%;
            }
        }

        @media (min-width: 540px) {
            #time-grid {
                width: 100%;
                display: grid;
                grid-template-columns: repeat(auto-fill, 6px);
                /* Adjust to fit 4x4px squares */
                grid-gap: 4px;
                /* Gap of 2px between squares */
                justify-content: center;
                /* Center grid items */
            }

            .time-square {
                width: 6px;
                height: 6px;
                background-color: #eeeeee;
                /* Very light gray */
                margin: 0px;
                /* Gap of 2px between squares */
            }

            .content-wrapper {
                display: flex;
                height: 100%;
                border: 1px solid #eeeeee;
                margin: 2rem 1rem;
                padding: 2rem;
                align-items: center;
                justify-content: center;
            }
        }

        .marginAdjust {
            margin-top: -1px;
        }

        .upwardClass {
            font-family: 'JetBrains Mono', monospace;
        }

        .check {
            padding: 10px;
            background-color: red;
        }

        /* Style for the textarea used for exporting data */
        #exported-data {
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #eeeeee;
            background-color: #000000;
            color: #eeeeee;
            padding: .5rem .5rem;
            margin: 0 0 .5rem 0;
            /* Add margin at the bottom */
            width: 100%;
            /* Full width */
            border-radius: 0;
            /* No border radius */
            resize: none;
            /* Disable resizing */
        }

        /* Style for the input field used for importing data */
        #import-data {
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #eeeeee;
            background-color: #000000;
            color: #eeeeee;
            padding: .5rem .5rem;
            height: 42px;
            /* Same height as other inputs */
            border-radius: 0;
            /* No border radius */
            text-align: center;
        }

        #import-data::placeholder {
            color: #bbbbbb;
            /* Placeholder color */
        }

        #import-data:focus {
            background-color: #333333;
            color: #eeeeee;
            outline: none;
            box-shadow: none;
        }

        .loadButton {
            padding: 0 32px;
            margin-left: -1px;
        }

        .input-group-css {
            margin: 0 auto;
            max-width: 328px;
        }
    </style>
</head>

<body>

    <!-- Bootstrap Modal -->
    <div class="modal fade" id="nameModal" tabindex="-1" role="dialog" aria-labelledby="modalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-sm" role="document">
            <div class="modal-content">
                <div class="modal-body">
                    <input type="text" id="subtimerNameInput" class="form-control" placeholder="Subtimer Name">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="saveNameButton">Save Name</button>
                </div>
            </div>
        </div>
    </div>


    <div class="container content-container" data-toggle="tooltip">
        <div class="content-wrapper">
            <div class="justify-content-center content-group">
                <div class="text-center">
                    <div id="input-group" class="input-group-css">
                        <div id="target-time-display" class="target-time mb-3"></div>
                        <div id="base-time-inputs-container">
                            <div class="d-flex justify-content-center">
                                <input type="number" id="hours-input" class="form-control brutalInput"
                                    placeholder="Hours" min="0" required style="display:none;">
                                <input type="number" id="minutes-input" class="form-control brutalInput"
                                    placeholder="Minutes" min="0" required>
                            </div>
                            <div class="" id="time-inputs-container">
                                <!-- Sub-timers added here -->
                            </div>
                        </div>
                        <div class="button-wrapper marginAdjust">
                            <button id="add-time-button" class="brutalButton">Add Time</button>
                            <button id="start-button" class="brutalButton">Start</button>
                        </div>
                    </div>
                    <div id="countdown-group" style="display: none;">
                        <div id="time-grid" class="">
                            <!-- Squares will be added dynamically using JavaScript -->
                        </div>
                        <div id="countdown-display" class="mt-3 relojito"></div>
                        <div id="upward-timer" style="display: none; font-size: 32px; text-align: center;"
                            class="mb-3 upwardClass">
                        </div>
                        <div id="subtimer-display"
                            class="d-flex flex-wrap justify-content-center marginAdjust subtimer-display-container">
                            <!-- Subtimer end times will be added here dynamically -->
                        </div>
                        <div class="button-wrapper">
                            <button id="pause-button" class="brutalButton">Pause</button>
                            <button id="reset-button" class="brutalButton">Reset</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let countdown;
        let endTime;
        let originalSeconds; // Declare originalSeconds
        let isPaused = false;
        let upwardTimerInterval;
        let upwardStartTime;
        let subtimerColors = [];

        // Function to simulate button click
        function simulateButtonClick(buttonId) {
            document.getElementById(buttonId).click();
        }

        let isSubtimerActive = false;

        document.getElementById('add-time-button').addEventListener('click', function () {
            var container = document.getElementById('time-inputs-container');
            var newInputGroup = document.createElement('div');
            newInputGroup.className = 'd-flex justify-content-center';
            newInputGroup.innerHTML = `
                <input type="number" class="form-control brutalInput marginAdjust" placeholder="Hours" min="0" style="display:none">
                <input type="number" class="form-control brutalInput marginAdjust" placeholder="Minutes" min="0">
            `;
            container.appendChild(newInputGroup);

            // Focus on the minutes input in the newly created input group
            newInputGroup.querySelector('input:last-child').focus();

            // Set isSubtimerActive to true when a new subtimer is added
            isSubtimerActive = true;
            localStorage.setItem('isSubtimerActive', isSubtimerActive.toString());
        });

        document.addEventListener('DOMContentLoaded', function () {
            // console.log("DOMContentLoaded event triggered");

            if (localStorage.getItem("endTime")) {
                endTime = parseInt(localStorage.getItem("endTime"));
                originalSeconds = parseInt(localStorage.getItem("originalSeconds"));
                isPaused = localStorage.getItem("isPaused") === "true";
                remainingTime = isPaused ? parseInt(localStorage.getItem("remainingTime")) : 0;

                // Check if the flag is set before initializing the grid
                if (localStorage.getItem('isGridPage') === 'true') {
                    initializeTimeGrid(originalSeconds);
                }

                toggleVisibility();

                if (isPaused) {
                    let currentTime = Date.now();
                    endTime = currentTime + remainingTime;
                    startCountdown();
                    document.getElementById("pause-button").textContent = "Pause";
                    isPaused = false;
                    localStorage.setItem("isPaused", isPaused.toString());
                } else {
                    startCountdown();
                }

                // Delay the application of colors to ensure the squares are ready
                setTimeout(() => {
                    const savedColors = JSON.parse(localStorage.getItem('squareColors') || '[]');
                    document.querySelectorAll('.time-square').forEach((square, index) => {
                        const color = savedColors[index];
                        if (color) {
                            square.style.backgroundColor = color;
                        }
                    });
                }, 100);
            }

            // Apply saved colors after initializing the grid
            const savedColors = JSON.parse(localStorage.getItem('squareColors') || '[]');

            if (localStorage.getItem("gridState")) {
                const gridState = JSON.parse(localStorage.getItem("gridState"));
                document.querySelectorAll(".time-square").forEach((square, index) => {
                    if (gridState[index]) {
                        square.style.backgroundColor = gridState[index];
                    }
                });
            }

            if (localStorage.getItem("upwardStartTime")) {
                upwardStartTime = parseInt(localStorage.getItem("upwardStartTime"));
                startUpwardTimer();
            }

            // Retrieve and initialize isSubtimerActive
            isSubtimerActive = localStorage.getItem('isSubtimerActive') === 'true';

            document.getElementById('base-time-inputs-container').addEventListener('keyup', function (event) {
                // Check if the event target is an input, the key is Enter, and the delay flag is true
                if (event.target.matches('input') && event.keyCode === 13 && event.target.enterKeyEnabled) {
                    simulateButtonClick('start-button');
                }
            });

            // Add a focus event listener to all input elements inside the container
            document.getElementById('base-time-inputs-container').addEventListener('focusin', function (event) {
                if (event.target.matches('input')) {
                    // Initially set the enterKeyEnabled flag to false
                    event.target.enterKeyEnabled = false;

                    // Enable the enterKeyEnabled flag after a one second delay
                    setTimeout(function () {
                        event.target.enterKeyEnabled = true;
                    }, 1000); // 1000 milliseconds = 1 second
                }
            }, true);

            // Check if there are saved compressed colors and decompress them
            if (localStorage.getItem('squareColors')) {
                const compressedColors = JSON.parse(localStorage.getItem('squareColors'));
                const decompressedColors = decompressColorsArray(compressedColors);

                const squares = document.querySelectorAll('.time-square');
                squares.forEach((square, index) => {
                    const color = decompressedColors[index];
                    if (color) {
                        square.style.backgroundColor = color;
                    }
                });
            }

            // Retrieve and use stored subtimer end times on page reload
            if (localStorage.getItem('subtimerEndTimes')) {
                logSubtimerEndTimes();
            }

            // Reapply saved subtimer styles on page reload
            if (localStorage.getItem('subtimerStyles')) {
                const subtimerStyles = JSON.parse(localStorage.getItem('subtimerStyles'));
                const subtimers = document.querySelectorAll('#subtimer-display div');

                subtimers.forEach((div, index) => {
                    const style = subtimerStyles[index];
                    if (style) {
                        div.style.color = style.color;
                        div.style.backgroundColor = style.rgbaColor;
                        div.style.opacity = style.opacity;

                        console.log(`Applied styles to Subtimer ${index + 1}: color = ${style.color}, rgbaColor = ${style.rgbaColor}, opacity = ${style.opacity}`);
                    }
                });
            }

            // Update the target time display with the current hour and minute
            let currentTime = new Date(Date.now());
            let hours = currentTime.getHours().toString().padStart(2, '0');
            let minutes = currentTime.getMinutes().toString().padStart(2, '0');
            document.getElementById('target-time-display').textContent = `Target: ${hours}:${minutes}`;

            subtimerColors = JSON.parse(localStorage.getItem('subtimerColors') || '[]');
            console.log(subtimerColors);

            $('#nameModal').on('hidden.bs.modal', function () {
                document.getElementById('subtimerNameInput').value = '';
            });

        });

        //Function to decompress the array of colors
        function decompressColorsArray(compressedColors) {
            let decompressed = [];

            compressedColors.forEach(item => {
                for (let i = 0; i < item.count; i++) {
                    decompressed.push(item.color);
                }
            });

            return decompressed;
        }

        document.getElementById('start-button').addEventListener('click', function () {
            let totalDuration = 0;

            // Only add main timer duration once
            let mainHours = parseInt(document.getElementById('hours-input').value) || 0;
            let mainMinutes = parseInt(document.getElementById('minutes-input').value) || 0;
            let mainDuration = mainHours * 3600 + mainMinutes * 60;

            // Add durations of all sub-timers
            document.querySelectorAll('#time-inputs-container > div').forEach((div) => {
                let hours = parseInt(div.querySelector('input:first-child').value) || 0;
                let minutes = parseInt(div.querySelector('input:last-child').value) || 0;
                totalDuration += hours * 3600 + minutes * 60; // Add each sub-timer duration
            });

            totalDuration += mainDuration;

            originalSeconds = totalDuration; // Set originalSeconds here
            endTime = Date.now() + totalDuration * 1000;

            initializeTimeGrid(totalDuration); // Initialize the grid with mainDuration
            toggleVisibility();
            startCountdown();

            localStorage.setItem('endTime', endTime.toString());
            localStorage.setItem('originalSeconds', originalSeconds.toString());
            localStorage.setItem('isPaused', 'false');

            // Defer the calculation and storage of subtimer end times
            setTimeout(() => {
                calculateAndStoreSubtimerEndTimes();
                logSubtimerEndTimes();
            }, 0);

            // When the user navigates to the grid page
            localStorage.setItem('isGridPage', 'true');
        });

        function getRandomColor() {
            const neonColors = [
                '#FC5B5B',
                '#FF925C',
                '#FFDE5C',
                '#AAF05F',
                '#5FDAF0',
                '#5F92F0',
                '#A55FF0',
            ];

            // Function to calculate hue difference between two colors
            function calculateHueDifference(color1, color2) {
                // Convert hex color to RGB
                function hexToRgb(hex) {
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : null;
                }

                // Convert RGB to HSL
                function rgbToHsl(r, g, b) {
                    r /= 255, g /= 255, b /= 255;
                    var max = Math.max(r, g, b), min = Math.min(r, g, b);
                    var h, s, l = (max + min) / 2;

                    if (max == min) {
                        h = s = 0; // achromatic
                    } else {
                        var d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }

                    return h * 360; // Return hue in degrees
                }

                // Get RGB values for both colors
                const rgb1 = hexToRgb(color1);
                const rgb2 = hexToRgb(color2);

                // Get hue values for both colors
                const hue1 = rgbToHsl(rgb1.r, rgb1.g, rgb1.b);
                const hue2 = rgbToHsl(rgb2.r, rgb2.g, rgb2.b);

                // Calculate and return the absolute difference in hue
                return Math.abs(hue1 - hue2);
            }

            // Check if all colors have been used
            if (usedColors.length === neonColors.length) {
                usedColors = []; // Reset the list if all colors have been used
            }

            let randomColor;
            let lastColor = usedColors[usedColors.length - 1]; // Get the last used color
            do {
                // Select a random index from the neonColors array
                const randomIndex = Math.floor(Math.random() * neonColors.length);
                randomColor = neonColors[randomIndex];
            } while (usedColors.includes(randomColor) || (lastColor && calculateHueDifference(randomColor, lastColor) < 120)); // Ensure the color hasn't been used already and has enough hue difference

            usedColors.push(randomColor); // Add the selected color to the list of used colors
            return randomColor;
        }

        // Initialize an array to keep track of used colors
        let usedColors = [];

        document.getElementById('pause-button').addEventListener('click', function () {
            if (isPaused) {
                // Resume the countdown
                endTime = Date.now() + remainingTime;
                startCountdown();
                this.textContent = 'Pause';
                isPaused = false;
            } else {
                // Pause the countdown
                clearInterval(countdown);
                remainingTime = endTime - Date.now(); // Save remaining time
                this.textContent = 'Resume';
                isPaused = true;
                localStorage.setItem('remainingTime', remainingTime.toString()); // Save remaining time
            }
            localStorage.setItem('isPaused', isPaused.toString());
        });

        document.getElementById('reset-button').addEventListener('click', function () {
            clearInterval(countdown);
            toggleVisibility();
            localStorage.clear(); // Clear local storage on reset

            clearInterval(upwardTimerInterval); // Stop the upward timer
            upwardStartTime = null; // Reset upwardStartTime to null
            document.getElementById('upward-timer').style.display = 'none';
            document.getElementById('upward-timer').textContent = '00:00:00'; // Reset the upward timer display

            let countdownDisplay = document.getElementById('countdown-display');
            countdownDisplay.style.fontSize = '128px'; // Reset font size
            countdownDisplay.style.marginTop = '0'; // Reset margin

            // Reset initial form values
            document.getElementById('hours-input').value = '';
            document.getElementById('minutes-input').value = '';

            //Clear all dynamically added time input groups
            var timeInputsContainer = document.getElementById('time-inputs-container');
            timeInputsContainer.innerHTML = ''; // Clear all child elements
            isSubtimerActive = false;
            localStorage.setItem('isSubtimerActive', isSubtimerActive.toString());
            // console.log('(reset)isSubtimerActive:', isSubtimerActive);

            // Reset the pause button's text to "Pause" and reset the isPaused flag
            document.getElementById('pause-button').textContent = 'Pause';
            isPaused = false;
            localStorage.setItem('isPaused', 'false'); // Update the isPaused flag in localStorage

            // Make sure the pause button is visible again on reset
            document.getElementById('pause-button').style.display = 'initial';

            // Update the target time display with the current hour and minute
            let currentTime = new Date(Date.now());
            let hours = currentTime.getHours().toString().padStart(2, '0');
            let minutes = currentTime.getMinutes().toString().padStart(2, '0');
            document.getElementById('target-time-display').textContent = `Target: ${hours}:${minutes}`;

            // Explicitly remove 'subtimerStyles' from localStorage on reset
            localStorage.removeItem('subtimerStyles');

            // When leaving the grid page or clicking the reset button
            localStorage.removeItem('isGridPage');
        });

        // Function to calculate and store the end times for the base timer and each subtimer
        function calculateTimerEndTimes() {
            let durations = [];

            // Include the base timer duration
            let mainHours = parseInt(document.getElementById('hours-input').value) || 0;
            let mainMinutes = parseInt(document.getElementById('minutes-input').value) || 0;
            durations.push(mainHours * 3600 + mainMinutes * 60);

            // Include durations of all sub-timers
            document.querySelectorAll('#time-inputs-container > div').forEach((div) => {
                let hours = parseInt(div.querySelector('input:first-child').value) || 0;
                let minutes = parseInt(div.querySelector('input:last-child').value) || 0;
                durations.push(hours * 3600 + minutes * 60);
            });

            // Calculate end times for each timer (base + subtimers)
            let currentTime = Date.now();
            let timerEndTimes = [];
            let accumulatedDuration = 0;
            durations.forEach(duration => {
                accumulatedDuration += duration;
                timerEndTimes.push(currentTime + accumulatedDuration * 1000);
            });

            return timerEndTimes;
        }

        function startCountdown() {
            // Calculate subtimer end times
            let timerEndTimes;

            // Check if timerEndTimes are stored in localStorage
            if (localStorage.getItem('subtimerEndTimes')) {
                timerEndTimes = JSON.parse(localStorage.getItem('subtimerEndTimes'));
            } else {
                // Calculate subtimer end times if not available
                timerEndTimes = calculateTimerEndTimes();
                localStorage.setItem('subtimerEndTimes', JSON.stringify(timerEndTimes));
            }

            countdown = setInterval(function () {
                let totalSeconds = Math.round((endTime - Date.now()) / 1000);
                updateDisplay(totalSeconds);

                // Check for each timer end time
                timerEndTimes.forEach(timerEndTime => {

                    if (Date.now() >= timerEndTime - 5000 && Date.now() < timerEndTime) {
                        handleBlinkingEffect(totalSeconds, document.getElementById('countdown-display'), true);
                    }
                });

                if (totalSeconds <= 0) {
                    clearInterval(countdown);

                    // Stop the blinking effect and ensure visibility
                    stopBlinking(document.getElementById('countdown-display'));

                    let countdownDisplay = document.getElementById('countdown-display');
                    countdownDisplay.textContent = 'â°';
                    countdownDisplay.style.fontSize = '64px'; // Reduced font size
                    countdownDisplay.style.marginTop = '16px'; // Reduced font size
                    animateGrid();

                    // Hide the pause button when the timer ends
                    document.getElementById('pause-button').style.display = 'none';
                }
                localStorage.setItem('endTime', endTime.toString());
            }, 1000);
        }

        function initializeTimeGrid(totalDuration) {
            const grid = document.getElementById('time-grid');
            grid.innerHTML = ''; // Clear existing squares if any

            subtimerColors = [];

            //Check if there are already saved colors in localStorage
            const savedColors = JSON.parse(localStorage.getItem('squareColors') || '[]');
            let colorsNeedSaving = savedColors.length === 0;

            //Log to check if the grid is initialized correctly
            // console.log("Initializing grid for duration:", totalDuration);

            // Add squares for the total duration
            let mainSquares = calculateTotalSquares(totalDuration);
            for (let i = 0; i < mainSquares; i++) {
                const square = document.createElement('div');
                square.classList.add('time-square');
                grid.appendChild(square);
            }

            //Collect durations from sub-timers to calculate the starting index for coloring
            let durations = Array.from(document.querySelectorAll('#time-inputs-container > div')).map(div => {
                let hours = parseInt(div.querySelector('input:first-child').value) || 0;
                let minutes = parseInt(div.querySelector('input:last-child').value) || 0;
                return hours * 3600 + minutes * 60;
            });

            //Reverse durations to start coloring from the bottom
            durations.reverse();

            //Modified logic to calculate the number of squares for each sub-timer based on total duration
            let subTimerEndIndex = mainSquares; // Start from the end of the grid
            durations.forEach(duration => {
                // Recalculate the number of squares for this sub-timer
                let subSquares = calculateSubTimerSquares(duration, totalDuration);
                let color = getRandomColor();

                // Store the color for this subtimer
                subtimerColors.push(color);

                // Color squares for this sub-timer
                for (let i = subTimerEndIndex - 1; i >= subTimerEndIndex - subSquares && i >= 0; i--) {
                    grid.children[i].style.backgroundColor = color;
                }
                subTimerEndIndex -= subSquares; // Move the index down for the next sub-timer
            });

            subtimerColors.push('#eeeeee');
            // Add this line to reverse the order of the array
            subtimerColors.reverse();

            if (colorsNeedSaving) {
                // Compress the colors array before saving
                const colors = Array.from(document.querySelectorAll('.time-square')).map(square => square.style.backgroundColor);
                const compressedColors = compressColorsArray(colors);
                localStorage.setItem('squareColors', JSON.stringify(compressedColors));
                // console.log("Compressed colors saved to localStorage:", compressedColors);
            }

            localStorage.setItem('subtimerColors', JSON.stringify(subtimerColors));

        }

        //Function to compress the array of colors using run-length encoding
        function compressColorsArray(colors) {
            let compressed = [];
            let previousColor = null;
            let count = 0;

            colors.forEach(color => {
                if (color === previousColor) {
                    count++;
                } else {
                    if (previousColor !== null) {
                        compressed.push({ color: previousColor, count: count });
                    }
                    previousColor = color;
                    count = 1;
                }
            });

            // Add the last color
            if (previousColor !== null) {
                compressed.push({ color: previousColor, count: count });
            }

            return compressed;
        }

        function calculateSubTimerSquares(subTimerDuration, totalDuration) {
            //Calculate the number of squares for a sub-timer based on the total duration
            let durationRatio = subTimerDuration / totalDuration;
            let totalSquares = calculateTotalSquares(totalDuration);
            return Math.ceil(totalSquares * durationRatio);
        }

        function calculateTotalSquares(duration) {
            if (duration > 7200) { // If duration is greater than 2 hours
                return Math.ceil(duration / 8); // One square every 8 seconds
            } else if (duration > 3600) {
                return Math.ceil(duration / 4); // Quarter the squares for durations greater than 1 hour
            } else if (duration > 1800) {
                return Math.ceil(duration / 2); // Half the squares for durations greater than 30 minutes
            } else {
                return duration;
            }
        }

        function updateDisplay(totalSeconds) {
            let countdownDisplay = document.getElementById('countdown-display');
            countdownDisplay.className = ''; // Reset classes

            // Update countdown display color based on remaining percentage
            let percentage = totalSeconds / originalSeconds;
            updateCountdownDisplayColor(countdownDisplay, percentage);
            countdownDisplay.textContent = totalSeconds <= 0 ? 0 : totalSeconds; // Display 0 when time is up

            // Update time grid colors
            updateTimeGridColors(totalSeconds, percentage);
            updateTimerColor(totalSeconds);

            handleBlinkingEffect(totalSeconds, countdownDisplay);
        }

        // Adjust the handleBlinkingEffect function
        function handleBlinkingEffect(totalSeconds, displayElement, isTimer) {
            const timeBeforeBlink = 10; // Time in seconds before we start blinking
            // Start blinking if within the time range and not already blinking
            if (isTimer || totalSeconds <= timeBeforeBlink) {

                if (!displayElement.blinking) {
                    // console.log("Blinking started");
                    startBlinking(displayElement);
                }
            }
            // Stop blinking if time is exceeded or if timer ends
            else if (totalSeconds > timeBeforeBlink || totalSeconds <= 0) {
                if (displayElement.blinking) {
                    // console.log("Blinking stopped");
                    stopBlinking(displayElement);
                }
            }
        }

        function startBlinking(element) {
            element.blinking = true;
            element.blinkInterval = setInterval(() => {
                element.style.visibility = element.style.visibility === 'hidden' ? 'visible' : 'hidden';
            }, 500); // Blink every half second
        }

        function stopBlinking(element) {
            clearInterval(element.blinkInterval);
            element.style.visibility = 'visible';
            element.blinking = false;
        }

        function updateCountdownDisplayColor(display, percentage) {

            display.classList.remove('text-warning', 'text-danger', 'shaking');
            if (!isSubtimerActive) {
                // console.log("No checkpoint active, should update to orange/red if necessary.");
                if (percentage > 0.5) {
                    // Normal state
                } else if (percentage > 0.25) {
                    display.classList.add('text-warning');
                } else if (percentage > 0.05) {
                    display.classList.add('text-danger');
                } else {
                    display.classList.add('text-danger', 'shaking');
                }
            } else {
                // console.log("Checkpoint active, updating squares for checkpoint.");
            }
        }

        function updateTimeGridColors(totalSeconds, percentage) {

            let totalSquares = calculateTotalSquares(originalSeconds);
            let elapsedSquares;

            if (originalSeconds > 7200) {
                elapsedSquares = Math.ceil((originalSeconds - totalSeconds) / 8);
            } else if (originalSeconds > 3600) {
                elapsedSquares = Math.ceil((originalSeconds - totalSeconds) / 4);
            } else if (originalSeconds > 1800) {
                elapsedSquares = Math.ceil((originalSeconds - totalSeconds) / 2);
            } else {
                elapsedSquares = originalSeconds - totalSeconds;
            }

            const squares = document.querySelectorAll('.time-square');
            squares.forEach((square, index) => {
                square.classList.remove('yellow', 'red');
                square.style.opacity = index < elapsedSquares ? '0.4' : '1';
                if (!isSubtimerActive) {
                    if (percentage > 0.5) {
                    } else if (percentage > 0.25) {
                        if (index >= elapsedSquares) square.classList.add('yellow');
                    } else {
                        if (index >= elapsedSquares) square.classList.add('red');
                    }
                } else {
                }
            });
        }

        function toggleVisibility() {
            var inputGroup = document.getElementById('input-group');
            var countdownGroup = document.getElementById('countdown-group');

            if (inputGroup.style.display === 'none') {
                inputGroup.style.display = 'block';
                countdownGroup.style.display = 'none';
            } else {
                inputGroup.style.display = 'none';
                countdownGroup.style.display = 'block';
            }
        }

        function animateGrid() {
            const squares = document.querySelectorAll('.time-square');
            const interval = 1000; // Interval in milliseconds for the color change effect

            // Array of neon colors
            const neonColors = [
                '#FC5B5B',
                '#FF925C',
                '#FFDE5C',
                '#AAF05F',
                '#5FDAF0',
                '#5F92F0',
                '#A55FF0',
            ];

            setInterval(() => {
                // Reset all squares to their original color and set opacity to 1
                squares.forEach(sq => {
                    sq.style.backgroundColor = '#5F5F5F'; // Original color
                    sq.style.opacity = '1'; // Full opacity
                });

                // Randomly select squares and change their color
                for (let i = 0; i < squares.length; i++) {
                    if (Math.random() < 0.25) { // Adjust the probability as needed
                        // Select a random color from the neonColors array
                        const randomColor = neonColors[Math.floor(Math.random() * neonColors.length)];

                        // Apply color change with full opacity
                        squares[i].style.transition = 'background-color 0.25s';
                        squares[i].style.backgroundColor = randomColor;
                        squares[i].style.opacity = '1'; // Ensure full opacity for color change
                    }
                }
            }, interval);
            startUpwardTimer();
        }

        function startUpwardTimer() {
            let currentTime = Date.now();

            if (!upwardStartTime) {
                // Check if the countdown has already finished while the script was inactive
                if (endTime && currentTime > endTime) {
                    // Calculate the time elapsed since the countdown finished
                    let elapsedSinceEnd = currentTime - endTime;
                    // Set the upwardStartTime to a past time reflecting the countdown end
                    upwardStartTime = currentTime - elapsedSinceEnd;
                } else {
                    // If the countdown hasn't finished, start the upward timer normally
                    upwardStartTime = currentTime;
                }
            }

            upwardTimerInterval = setInterval(function () {
                updateUpwardTimer();
            }, 1000);

            document.getElementById('upward-timer').style.display = 'block';
            localStorage.setItem('upwardStartTime', upwardStartTime.toString());
        }

        function updateUpwardTimer() {
            let elapsed = Date.now() - upwardStartTime;
            let hours = Math.floor(elapsed / 3600000);
            let minutes = Math.floor((elapsed % 3600000) / 60000);
            let seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('upward-timer').textContent =
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerColor(totalSeconds) {
            const squares = document.querySelectorAll('.time-square');
            let countdownDisplay = document.getElementById('countdown-display');
            let elapsedSquares = calculateElapsedSquares(originalSeconds, totalSeconds);

            // Check if the elapsed time has reached the subtimer squares
            if (elapsedSquares < squares.length) {
                let currentSquare = squares[elapsedSquares];
                // If the current square is a subtimer square (not white and not empty), update the color
                if (currentSquare.style.backgroundColor !== '' && currentSquare.style.backgroundColor !== 'white') {
                    countdownDisplay.style.color = currentSquare.style.backgroundColor;
                } else {
                    // Default color if no special subtimer is active
                    countdownDisplay.style.color = '#ffffff'; // White color
                }
            } else {
                // Default color if the time has elapsed beyond the grid
                countdownDisplay.style.color = '#ffffff'; // White color
            }
        }

        function calculateElapsedSquares(originalSeconds, totalSeconds) {
            if (originalSeconds > 7200) {
                return Math.ceil((originalSeconds - totalSeconds) / 8);
            } else if (originalSeconds > 3600) {
                return Math.ceil((originalSeconds - totalSeconds) / 4);
            } else if (originalSeconds > 1800) {
                return Math.ceil((originalSeconds - totalSeconds) / 2);
            } else {
                return originalSeconds - totalSeconds;
            }
        }

        // Modified function to calculate and store subtimer end times
        function calculateAndStoreSubtimerEndTimes() {
            let timerEndTimes = calculateTimerEndTimes();
            localStorage.setItem('subtimerEndTimes', JSON.stringify(timerEndTimes));
        }

        // Function to log subtimer end times and save their styles
        function logSubtimerEndTimes() {
            let timerEndTimes = JSON.parse(localStorage.getItem('subtimerEndTimes') || '[]');
            const subtimerDisplay = document.getElementById('subtimer-display');
            subtimerDisplay.innerHTML = '';

            // Retrieve existing styles from localStorage or initialize if not present
            let subtimerStyles = JSON.parse(localStorage.getItem('subtimerStyles')) || [];

            // Check if we need to update subtimerStyles based on timerEndTimes length
            let shouldUpdateStyles = subtimerStyles.length !== timerEndTimes.length;

            timerEndTimes.forEach((endTime, index) => {
                const timeString = new Date(endTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                console.log(`Subtimer ${index + 1}: Ends at ${timeString}`);

                const subtimerDiv = document.createElement('div');
                subtimerDiv.textContent = timeString;
                subtimerDiv.className = 'subTimerStyle';
                subtimerDiv.dataset.endTime = endTime;

                // Add click event listener to each subtimer for setting a name
                subtimerDiv.addEventListener('click', function () {
                    // Save the current index to a variable accessible by the modal save button
                    currentSubtimerIndex = index;

                    // Show the modal
                    $('#nameModal').modal('show');
                });

                document.getElementById('subtimerNameInput').addEventListener('keydown', function (event) {
                    if (event.key === 'Enter') {
                        // Trigger save action
                        document.getElementById('saveNameButton').click();
                    }
                });

                document.addEventListener('keydown', function (event) {
                    if (event.key === 'Escape') {
                        // Check if modal is open
                        if ($('#nameModal').hasClass('show')) {
                            $('#nameModal').modal('hide');
                        }
                    }
                });

                document.getElementById('saveNameButton').addEventListener('click', function () {
                    const name = document.getElementById('subtimerNameInput').value;
                    if (name) {
                        const currentSubtimerDiv = document.querySelectorAll('.subTimerStyle')[currentSubtimerIndex];

                        // Set the title for Bootstrap tooltip and immediately initialize it
                        currentSubtimerDiv.setAttribute('title', name);
                        $(currentSubtimerDiv).tooltip();

                        // Remove the title attribute to prevent default browser tooltip
                        currentSubtimerDiv.removeAttribute('title');

                        // Optionally, set data-original-title for Bootstrap tooltip
                        $(currentSubtimerDiv).attr('data-original-title', name);

                        // Save the name in local storage
                        localStorage.setItem('subtimerName' + currentSubtimerIndex, name);

                        // Hide the modal
                        $('#nameModal').modal('hide');
                    }
                });

                $('#nameModal').on('shown.bs.modal', function () {
                    $('#subtimerNameInput').focus();
                });

                // Initialize tooltip if name is already set
                let storedName = localStorage.getItem('subtimerName' + index);
                if (storedName) {
                    subtimerDiv.setAttribute('title', storedName);
                    $(subtimerDiv).tooltip();
                }

                if (subtimerColors[index]) {
                    const textColor = subtimerColors[index];
                    subtimerDiv.style.color = textColor;

                    // Convert hex to RGBA and set as background color
                    const rgbaColor = convertHexToRGBA(textColor, 0.2);
                    subtimerDiv.style.backgroundColor = rgbaColor;

                    // Update the style information if needed
                    if (shouldUpdateStyles || !subtimerStyles[index] || subtimerStyles[index].color !== textColor) {
                        subtimerStyles[index] = { color: textColor, rgbaColor: rgbaColor, opacity: 1 };
                    }
                } else if (shouldUpdateStyles || !subtimerStyles[index]) {
                    // Update default style if no color is defined
                    subtimerStyles[index] = { color: null, rgbaColor: null, opacity: 1 };
                }

                subtimerDisplay.appendChild(subtimerDiv);
            });

            if (shouldUpdateStyles) {
                // Save the updated styles to localStorage only if necessary
                localStorage.setItem('subtimerStyles', JSON.stringify(subtimerStyles));
                console.log('Updated and saved subtimerStyles:', subtimerStyles);
            } else {
                console.log('No update required for subtimerStyles');
            }

            // Interval check to update opacity of subtimers
            setInterval(() => {
                const currentTime = Date.now();
                document.querySelectorAll('#subtimer-display div').forEach((div, index) => {
                    const subtimerEndTime = parseInt(div.dataset.endTime);
                    if (subtimerEndTime < currentTime) {
                        div.style.opacity = 0.4;
                        if (subtimerStyles[index]) {
                            subtimerStyles[index].opacity = 0.4; // Update the stored opacity
                        }
                    } else {
                        div.style.opacity = 1;
                        if (subtimerStyles[index]) {
                            subtimerStyles[index].opacity = 1; // Update the stored opacity
                        }
                    }
                });
            }, 2000); // Check every minute
        }

        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })

        // Function to convert hex color to RGBA
        function convertHexToRGBA(hex, opacity) {
            let r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);

            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        // Function to calculate and display the estimated target time based on current time and timer inputs
        function updateTargetTimeDisplay() {
            let totalDurationInSeconds = 0;

            // Include the base timer duration
            let mainHours = parseInt(document.getElementById('hours-input').value) || 0;
            let mainMinutes = parseInt(document.getElementById('minutes-input').value) || 0;
            totalDurationInSeconds += (mainHours * 3600 + mainMinutes * 60);

            // Include durations of all sub-timers
            document.querySelectorAll('#time-inputs-container > div').forEach((div) => {
                let hours = parseInt(div.querySelector('input:first-child').value) || 0;
                let minutes = parseInt(div.querySelector('input:last-child').value) || 0;
                totalDurationInSeconds += (hours * 3600 + minutes * 60);
            });

            // Calculate target time based on current time and total duration
            let currentTime = new Date();
            let targetTime = new Date(currentTime.getTime() + totalDurationInSeconds * 1000);
            let targetHours = targetTime.getHours();
            let targetMinutes = targetTime.getMinutes();

            // Update the display
            let targetTimeDisplay = document.getElementById('target-time-display');
            targetTimeDisplay.textContent = `Target: ${targetHours.toString().padStart(2, '0')}:${targetMinutes.toString().padStart(2, '0')}`;
        }

        // Adding event listeners to update target time display
        document.getElementById('base-time-inputs-container').addEventListener('input', updateTargetTimeDisplay);
        document.getElementById('time-inputs-container').addEventListener('input', updateTargetTimeDisplay);

        // Event listener for handling Shift + Up/Down arrow keys for input fields
        document.body.addEventListener('keydown', function (event) {
            // Check if the event target is an input within the specified containers
            if (event.target.matches('#base-time-inputs-container input[type="number"], #time-inputs-container input[type="number"]')) {
                handleShiftArrowKeys(event);
            }
        });

        function handleShiftArrowKeys(event) {
            // Check for Shift + Up Arrow or Shift + Down Arrow key combinations
            if (event.shiftKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) {
                event.preventDefault(); // Prevent the default action

                let currentValue = parseInt(event.target.value) || 0;
                if (event.key === 'ArrowUp') {
                    event.target.value = currentValue + 10; // Increment by 10
                } else if (event.key === 'ArrowDown') {
                    event.target.value = currentValue - 10; // Decrement by 10
                    if (event.target.value < 0) event.target.value = 0; // Ensure value does not go below 0
                }

                updateTargetTimeDisplay(); // Update the target time display
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"
        integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct"
        crossorigin="anonymous"></script>
</body>

</html>